#!/bin/bash
#
# bash completion file for core hyper commands
#
# This script provides completion of:
#  - commands and their options
#  - container ids and names
#  - image repos and tags
#  - filepaths
# To enable the completions:
# - place this file in /etc/bash_completion.d
#
# Configuration:
#
# For several commands, the amount of completions can be configured by
# setting environment variables.
#
# You can tailor completion for the "events", "history", "inspect", "run",
# "rmi" and "save" commands by settings the following environment
# variables:
#
# HYPER_COMPLETION_SHOW_IMAGE_IDS
#   "none" - Show names only (default)
#   "non-intermediate" - Show names and ids, but omit intermediate image IDs
#   "all" - Show names and ids, including intermediate image IDs
#
# HYPER_COMPLETION_SHOW_TAGS
#   "yes" - include tags in completion options (default)
#   "no"  - don't include tags in completion options

__hyper_previous_extglob_setting=$(shopt -p )
shopt -s extglob

__hyper_q() {
	hyper ${host:+-H "$host"} ${config:+--config "$config"} 2>/dev/null "$@"
}

__hyper_complete_containers_all() {
	local IFS=$'\n'
	local containers=( $(__hyper_q ps -aq --no-trunc) )
	if [ "$1" ]; then
		containers=( $(__hyper_q inspect --format "{{if $1}}{{.Id}}{{end}}" "${containers[@]}") )
	fi
	local names=( $(__hyper_q inspect --format '{{.Name}}' "${containers[@]}") )
	names=( "${names[@]#/}" ) # trim off the leading "/" from the container names
	unset IFS
	COMPREPLY=( $(compgen -W "${names[*]} ${containers[*]}" -- "$cur") )
}

__hyper_complete_containers_running() {
	__hyper_complete_containers_all '.State.Running'
}

__hyper_complete_containers_stopped() {
	__hyper_complete_containers_all 'not .State.Running'
}

__hyper_complete_containers_pauseable() {
	__hyper_complete_containers_all 'and .State.Running (not .State.Paused)'
}

__hyper_complete_containers_unpauseable() {
	__hyper_complete_containers_all '.State.Paused'
}

__hyper_complete_images() {
	local images_args=""

	case "$HYPER_COMPLETION_SHOW_IMAGES_IDS" in
		all)
			images_args="--no-trunc -a"
			;;
		non-intermediate)
			images_args="--no-trunc"
			;;
	esac

	local repo_print_command
	if [ "${HYPER_COMPLETION_SHOW_TAGS:-yes}" = "yes" ]; then
		repo_print_command='print $1; print $1":"$2'
	else
		repo_print_command='print $1'
	fi

	local awk_script
	case "$HYPER_COMPLETION_SHOW_IMAGE_IDS" in
		all|non-intermediate)
			awk_script='NR>1 { print $3; if ($1 != "<none>") { '"$repo_print_command"' } }'
			;;
		none|*)
			awk_script='NR>1 && $1 != "<none>" { '"$repo_print_command"' }'
			;;
	esac

	local images=$(__hyper_q images $images_args | awk "$awk_script")
	COMPREPLY=( $(compgen -W "$images" -- "$cur") )
	__ltrim_colon_completions "$cur"
}

__hyper_complete_image_repos() {
	local repos="$(__hyper_q images | awk 'NR>1 && $1 != "<none>" { print $1 }')"
	COMPREPLY=( $(compgen -W "$repos" -- "$cur") )
}

__hyper_complete_log_levels() {
	COMPREPLY=( $( compgen -W "debug info warn error fatal" -- "$cur" ) )
}

# Transforms a multiline list of strings into a single line string
# with the words separated by "|".
# This is used to prepare arguments to __hyper_pos_first_nonflag().
__hyper_to_alternatives() {
	local parts=( $1 )
	local IFS='|'
	echo "${parts[*]}"
}

# Transforms a multiline list of options into an extglob pattern
# suitable for use in case statements
__hyper_to_extglob() {
	local extglob=$( __hyper_to_alternatives "$1" )
	echo "@($extglob)"
}

# Finds the position of the first word that is neither option nor an option's argument.
# If there are options that require arguments, you should pass a glob describing those
# options, e.g. "--option1|-o|--option2"
# Use this function to restrict completions to exact positions after the argument list
__hyper_pos_first_nonflag() {
	local argument_flags=$1

	local counter=$((${subcommand_pos:-${command_pos}} + 1))
	while [ $counter -le $cword ]; do
		if [ -n "$argument_flags" ] && eval "case '${words[$counter]}' in $argument_flags) true ;; *) false ;; esac"; then
			(( counter++ ))
			# eat "=" in case of --option=arg syntax
			[ "${words[$counter]}" = "=" ] && (( counter++ ))
		else
			case "${words[$counter]}" in
				-*)
					;;
				*)
					break
					;;
			esac
		fi

		# Bash splits words at "=", retaining "=" as a word, examples:
		# "--debug=false" => 3 words, "--log-opt syslog-facility=daemon" => 4 words
		while [ "${words[$counter + 1]}" = "=" ] ; do
			counter=$(( counter + 2 ))
		done

		(( counter++ ))
	done

	echo $counter
}

# suppress trailing whitespace
__hyper_nospace() {
	# compopt is not available in ancient bash versions
	type compopt &>/dev/null && compopt -o nospace
}

_hyper_attach() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --no-stdin" -- "$cur" ) )
			;;
		*)
			__hyper_complete_containers_running
			;;
	esac
}

_hyper_config() {
	COMPREPLY=( $( compgen -W "--accesskey --secretkey" -- "$cur" ) )
}

_hyper_exec() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--detach -d --help --interactive -i --tty -t" -- "$cur" ) )
			;;
		*)
			__hyper_complete_containers_running
			;;
	esac
}

_hyper_history() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help --no-trunc --quiet -q" -- "$cur" ) )
			;;
		*)
			__hyper_complete_images
			;;
	esac
}

_hyper_images() {
	case "$prev" in
		--filter|-f)
			COMPREPLY=( $( compgen -S = -W "dangling label" -- "$cur" ) )
			__hyper_nospace
			return
			;;
                --format)
			return
			;;
	esac

	case "${words[$cword-2]}$prev=" in
		*dangling=*)
			COMPREPLY=( $( compgen -W "true false" -- "${cur#=}" ) )
			return
			;;
		*label=*)
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--all -a --digests --filter -f --format --help --no-trunc --quiet -q" -- "$cur" ) )
			;;
		=)
			return
			;;
		*)
			__hyper_complete_image_repos
			;;
	esac
}

_hyper_info() {
	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "--help" -- "$cur" ) )
			;;
	esac
}

# global options that may appear after the docker command
_hyper_hyper() {
	local boolean_options="
		$global_boolean_options
		--help
		--version -v
	"

	case "$prev" in
		--config)
			_filedir -d
			return
			;;
		--log-level|-l)
			__hyper_complete_log_levels
			return
			;;
		$(__hyper_to_extglob "$global_options_with_args") )
			return
			;;
	esac

	case "$cur" in
		-*)
			COMPREPLY=( $( compgen -W "$boolean_options $global_options_with_args" -- "$cur") )
			;;
		*)
			local counter=$( __hyper_pos_first_nonflag $(__hyper_to_extglob "$global_options_with_args") )
			if [ $cword -eq $counter ]; then
				COMPREPLY=( $( compgen -W "${commands[*]} help" -- "$cur" ) )
			fi
			;;
	esac
}

_hyper() {
	local previous_extglob_setting=$(shopt -p extglob)
	shopt -s extglob

	local commands=(
		attach
		compose
		config
		create
		cron
		exec
		fip
		history
		images
		info
		inspect
		kill
		load
		login
		logout
		logs
		port
		ps
		pull
		rename
		restart
		rm
		rmi
		run
		search
		service
		sg
		snapshot
		start
		stats
		stop
		update
		version
		volume
	)

	local global_boolean_options="
		--debug -D
	"

	local global_options_with_args="
		--config
		--host -H
		--log-level -l
	"

	local host config

	COMPREPLY=()
	local cur prev words cword
	_get_comp_words_by_ref -n : cur prev words cword

	local command='hyper' command_pos=0 subcommand_pos
	local counter=1
	while [ $counter -lt $cword ]; do
		case "${words[$counter]}" in
			# save host so that completion can use custom daemon
			--host|-H)
				(( counter++ ))
				host="${words[$counter]}"
				;;
			# save config so that completion can use custom configuration directories
			--config)
				(( counter++ ))
				config="${words[$counter]}"
				;;
			$(__hyper_to_extglob "$global_options_with_args") )
				(( counter++ ))
				;;
			-*)
				;;
			=)
				(( counter++ ))
				;;
			*)
				command="${words[$counter]}"
				command_pos=$counter
				break
				;;
		esac
		(( counter++ ))
	done

	local completions_func=_hyper_${command}
	declare -F $completions_func >/dev/null && $completions_func

	eval "$previous_extglob_setting"
	return 0
}

eval "$__hyper_previous_extglob_setting"
unset __hyper_previous_extglob_setting

complete -F _hyper hyper
